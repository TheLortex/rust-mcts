#![allow(non_snake_case)]
#![feature(type_alias_impl_trait)]

use ggpf_gym::*;

use std::future::Future;
use tarpc::{
    context,
    server::{BaseChannel, Channel},
};
use tokio::stream::StreamExt;

use std::sync::{Arc, Mutex};

#[derive(Clone)]
struct GymServer {
    game: Arc<Mutex<Option<(gym::Environment, bool)>>>,
}

impl GymRunner for GymServer {
    type InitFut = impl Future<Output = ()>;

    fn init(self, _: context::Context, game: String, render: bool) -> Self::InitFut {
        log::debug!("Init.");
        async move {
            let gym = gym::GymClient::default();
            let game = gym.make(&game);

            *self.game.lock().unwrap() = Some((game, render));
        }
    }

    type ResetFut = impl Future<Output = gym::SpaceData>;

    fn reset(self, _: context::Context) -> Self::ResetFut {
        log::debug!("Reset.");

        async move {
            if let Some((ref game, render)) = *self.game.lock().unwrap() {
                let res = game.reset().unwrap();
                if render {
                    game.render();
                }
                res
            } else {
                panic!("The game hasn't been initialized.");
            }
        }
    }

    type PlayFut = impl Future<Output = gym::State>;

    fn play(self, _: context::Context, action: usize) -> Self::PlayFut {
        log::debug!("Play {}.", action);

        async move {
            if let Some((ref game, render)) = *self.game.lock().unwrap() {
                let res = game.step(&gym::SpaceData::DISCRETE(action)).unwrap();
                if render {
                    game.render();
                }
                res
            } else {
                panic!("The game hasn't been initialized.");
            }
        }
    }

    type ActionSpaceFut = impl Future<Output = gym::SpaceTemplate>;

    fn action_space(self, _: context::Context) -> Self::ActionSpaceFut {
        log::debug!("Action space");
        async move {
            if let Some((ref game,_)) = *self.game.lock().unwrap() {
                game.action_space().clone()
            } else {
                panic!("The game hasn't been initialized.");
            }
        }
    }

    type ObservationSpaceFut = impl Future<Output = gym::SpaceTemplate>;

    fn observation_space(self, _: context::Context) -> Self::ObservationSpaceFut {
        log::debug!("Observation space");
        async move {
            if let Some((ref game,_)) = *self.game.lock().unwrap() {
                game.observation_space().clone()
            } else {
                panic!("The game hasn't been initialized.");
            }
        }
    }
}

use std::net::{IpAddr, SocketAddr};
use tokio_serde::formats::Json;
use tokio::prelude::*;

#[tokio::main]
async fn main() {
    flexi_logger::Logger::with_env().start().unwrap();
    log::info!("GYM!");
    let mut transport = tarpc::serde_transport::tcp::listen("localhost:1337", BinCodec::default)
        .await
        .unwrap();
    let addr = transport.local_addr();
    log::info!("Listening on {}", addr);

    // For this example, we're just going to wait for one connection.
    let mut stream = transport
        .filter_map(|r| r.ok())
        .map(BaseChannel::with_defaults);

    while let Some(client) = stream.next().await {
        tokio::spawn({
            log::info!("New client.");
            let gym_server = GymServer {
                game: Arc::new(Mutex::new(None)),
            };
            client.respond_with(gym_server.serve()).execute()
        });
    }
    /*

    // `Channel` is a trait representing a server-side connection. It is a trait to allow
    // for some channels to be instrumented: for example, to track the number of open connections.
    // BaseChannel is the most basic channel, simply wrapping a transport with no added
    // functionality.
    BaseChannel::with_defaults(client)
        // serve_world is generated by the tarpc::service attribute. It takes as input any type
        // implementing the generated World trait.
        .respond_with(gym_server.serve())
        .execute()
        .await;*/
    

    /*
    let gym = GymClient::default();
    let game = gym.make("MsPacman-v0");
    log::info!("{:?}", game.reset());

    let t0 = time::Instant::now();
    let mut i = 0;
    while i < 1000 {
        let res = game.step(&SpaceData::DISCRETE(0)).unwrap();
        //game.render();
        i += 1;

        if res.is_done {
            game.reset();
        }
    }

    let t1 = time::Instant::now();
    println!("T: {:?}, {}", t1 - t0, i);*/

    /*
    let mut threaded_rt = runtime::Builder::new()
        .threaded_scheduler()
        .enable_all()
        .core_threads(8)
        .build()
        .unwrap();

    threaded_rt.block_on(run());*/
}
